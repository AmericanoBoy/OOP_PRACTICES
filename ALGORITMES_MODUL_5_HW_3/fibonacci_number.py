

import sys #импортируем сторонний модуль для увеличения глубины рекурсии в случае необходимости
def fibonacci_number(number: int) -> int:
    '''
    рекурсивная функция, принимающая на вход число и возвращающая это число в пос_ти фибоначи
    :param number: 1,3,4
    :return: 8
    прим: в функции предусмотрен лимит, связанный с оптимальным исползованием рекурсивной функции,
    т.к. при аргументе функции, большем 960 функция становится неэффективной и ресурсоемкой.
    при аргументе равным или меньшем 480, в который укладывается встроенный лимит вызова рекурсии,
    равный 1000 - мы оставляем его без изменений. в случае, если исходный аргумент превосходит
    число 480 - мы применяем вычисленный мною кооэфициент равный приблизително 2.09 на который
    нужно умножать исходный аргумент функции, чтобы посчитать необходимую нам глубину рекурсии.
    '''

    if not isinstance(number, int): raise TypeError('ИСКОМЫЙ НОМЕР ЧИСЛА ФИБОНАЧИ ДОЛЖЕН БЫТЬ ТИПОМ |int| !')
    if number < 1: raise ValueError('ВХОДНЫЕ ДАННЫЕ ДОЛЖНЫ БЫТЬ БОЛЬШЕ НУЛЯ !')
    if number > 960: raise ValueError('ВВЕДЕНО СЛИШКОМ БОЛЬШОЕ ЧИСЛО ДЛЯ НАХОЖДЕНИЯ С ПОМОЩЬЮ РЕКУРСИИ !')
    limit_recursion = [1000, 2.09 * number][number > 480] #вычисляем необходимый лимит рекурсии
    sys.setrecursionlimit(limit_recursion) #увеличиваем встроенный лимит рекурсии в случае необходимости
    return 1 if (number == 1 or number == 2) else fibonacci_number(number - 1) + fibonacci_number(number - 2)
