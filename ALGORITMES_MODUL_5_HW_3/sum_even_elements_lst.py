
import sys #импортируем сторонний модуль для увеличения глубины рекурсии в случае необходимости
def check_iter_data(data): #функция контроля принадлежности итерируемого эл_та к типу |int, float|
    if not isinstance(data, (int, float)): raise TypeError('ТИП ИТЕРИРУЕМОГО ЭЛ_ТА ДОЛЖЕН БЫТЬ |int, float| !')
    return data

def sum_even_elements_lst(array: list) -> int or float:
    '''
    рекурсивная функция, вычисляющая сумму всех четных эл_ов массива
    :param array: [1,2,3,4,5]
    :return: 6
    прим: в функции предусмотрен лимит, связанный с оптимальным исползованием рекурсивной функции,
    т.к. при длине списка, большем 2000 функция становится неэффективной и ресурсоемкой.
    при длине списка равным или меньшем 995, в который укладывается встроенный лимит вызова рекурсии,
    равный 1000 - мы оставляем его без изменений. в случае, если исходный длина списка превосходит
    число 995 - мы увеличиваем лимит вызова рекурсивной функции, превосходящей длину списка на число 10,
    но изначально ограничиваем кол_во рекурсий лимитом в 2000.
    '''

    if not isinstance(array, list): raise TypeError('ВХОДНЫЕ ДАННЫЕ ДОЛЖНЫ БыТЬ ТИПОМ |list| !')
    len_array = len(array)
    if len_array > 2000: raise ValueError('В КАЧЕСТВЕ АРГУМЕНТА ПОЛУЧЕН СЛИШКОМ ДЛИННЫЙ СПИСОК ДЛЯ НАХОЖДЕНИЯ СУММЫ ЕГО ЧЕТНЫХ ЭЛ_ОВ С ПОМОЩЬЮ РЕКУРСИИ !')
    limit_recursion = [1000, 10 + len_array][len_array > 995]  # вычисляем необходимый лимит рекурсии
    sys.setrecursionlimit(limit_recursion)  # увеличиваем встроенный лимит рекурсии в случае необходимости
    return 0 if array == [] else (check_iter_data(array[0]) % 2 == 0) * array[0] + sum_even_elements_lst(array[1:])
