
import sys #импортируем сторонний модуль для увеличения глубины рекурсии в случае необходимости
def control_string_is_palindrome(string: str) ->bool:
    '''
    рекурсивная функция, определяющая является ли строка палиндромом
    :param string: 'боб'
    :return: True
    прим: в функции предусмотрен лимит, связанный с оптимальным исползованием рекурсивной функции,
    т.к. при длине строки, большем 2000 функция становится неэффективной и ресурсоемкой.
    при длине строки равным или меньшем 995, в который укладывается встроенный лимит вызова рекурсии,
    равный 1000 - мы оставляем его без изменений. в случае, если исходная длина строки превосходит
    число 995 - мы увеличиваем лимит вызова рекурсивной функции, превосходящей длину списка на число 10,
    но изначально ограничиваем кол_во рекурсий лимитом в 2000.
    '''

    if not isinstance(string, str): raise TypeError('ВХОДНЫЕ ДАННЫЕ ДОЛЖНЫ БЫТЬ ТИПОМ |str| !')
    len_string = len(string)
    if len_string > 2000: raise ValueError('В КАЧЕСТВЕ АРГУМЕНТА ПОЛУЧЕН СЛИШКОМ ДЛИННАЯ СТРОКА ДЛЯ ОПРЕДЕЛЕНИЯ С ПОМОЩЬЮ РЕКУРСИИ !')
    limit_recursion = [1000, 10 + len_string][len_string > 995] #вычисляем необходимый лимит рекурсии
    sys.setrecursionlimit(limit_recursion)  # увеличиваем встроенный лимит рекурсии в случае необходимости
    if len(string) <= 1: return True
    return [control_string_is_palindrome(string[1:len(string)-1]), False][string[0] != string[len(string)-1]]
