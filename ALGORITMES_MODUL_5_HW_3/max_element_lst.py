
import sys #импортируем сторонний модуль для увеличения глубины рекурсии в случае необходимости

def control_iteration_data(data): #функция контроля принадлежности итерируемого эл_та к типу |int, float|
    if not isinstance(data, (int, float)): raise TypeError('ТИП ИТЕРИРУЕМОГО ЭЛ_ТА ДОЛЖЕН БЫТЬ |int, float| !')
    return data
def max_element_lst(array: list) ->int or float:
    '''
    рекурсивная функция, вычисляющая максимальный элемент списка
    :param array: [1,3,7,4,5]
    :return: 7
    прим: в функции предусмотрен лимит, связанный с оптимальным исползованием рекурсивной функции,
    т.к. при длине списка, большем 2000 функция становится неэффективной и ресурсоемкой.
    при длине списка равным или меньшем 995, в который укладывается встроенный лимит вызова рекурсии,
    равный 1000 - мы оставляем его без изменений. в случае, если исходный длина списка превосходит
    число 995 - мы увеличиваем лимит вызова рекурсивной функции, превосходящей длину списка на число 10,
    но изначально ограничиваем кол_во рекурсий лимитом в 2000.
    '''

    if not isinstance(array, list): raise TypeError('ТИП ВХОДНЫХ ДАННЫХ ДОЛЖЕН БЫТЬ |int| !')
    len_array = len(array)
    if len_array == 0: return 0
    if len_array > 2000: raise ValueError('В КАЧЕСТВЕ АРГУМЕНТА ПОЛУЧЕН СЛИШКОМ ДЛИННЫЙ СПИСОК ДЛЯ НАХОЖДЕНИЯ МАКС. ЭЛ. С ПОМОЩЬЮ РЕКУРСИИ !')
    limit_recursion = [1000, 10 + len_array][len_array > 995] #вычисляем необходимый лимит рекурсии
    sys.setrecursionlimit(limit_recursion)  # увеличиваем встроенный лимит рекурсии в случае необходимости
    return [max_element_lst(array[1:]), array[0]][control_iteration_data(array[0]) > max_element_lst(array[1:])]
